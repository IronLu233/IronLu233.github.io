<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Iron&#39;s Blog | React redux源码解析</title>
    <meta name="description" content="Just recording something">
    
    
    <link rel="preload" href="/assets/css/23.styles.40677ac6.css" as="style"><link rel="preload" href="/assets/js/app.0caf2975.js" as="script"><link rel="preload" href="/assets/js/7.5fb1dc3c.js" as="script"><link rel="prefetch" href="/assets/js/0.9f59e96c.js"><link rel="prefetch" href="/assets/js/1.9710c8e3.js"><link rel="prefetch" href="/assets/js/2.717bf58a.js"><link rel="prefetch" href="/assets/js/3.eb3ce0d5.js"><link rel="prefetch" href="/assets/js/4.81a9fd94.js"><link rel="prefetch" href="/assets/js/5.0289cb67.js"><link rel="prefetch" href="/assets/js/6.58a56d39.js"><link rel="prefetch" href="/assets/js/8.af6cf755.js"><link rel="prefetch" href="/assets/js/9.d4b854ad.js"><link rel="prefetch" href="/assets/js/10.f94d82bf.js"><link rel="prefetch" href="/assets/js/11.68ad2dfd.js"><link rel="prefetch" href="/assets/js/12.fe4f1f96.js"><link rel="prefetch" href="/assets/js/13.1594182b.js"><link rel="prefetch" href="/assets/js/14.5e2158c7.js"><link rel="prefetch" href="/assets/js/15.cb7e4c09.js"><link rel="prefetch" href="/assets/js/16.637e1af2.js"><link rel="prefetch" href="/assets/js/17.c68f0f15.js"><link rel="prefetch" href="/assets/js/18.3f6c685d.js"><link rel="prefetch" href="/assets/js/19.5d57c2ad.js"><link rel="prefetch" href="/assets/js/20.725e2252.js"><link rel="prefetch" href="/assets/js/21.c0d37235.js"><link rel="prefetch" href="/assets/js/22.c549c2ec.js">
    <link rel="stylesheet" href="/assets/css/23.styles.40677ac6.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div><a href="/" class="home-link router-link-active"><!----><span class="site-name">
      Iron's Blog
    </span></a><div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""><!----></div><!----></div></header><div class="sidebar-mask"></div><div class="sidebar"><!----><!----></div><div class="page"><div class="content"><h1 id="react-redux源码解析"><a href="#react-redux源码解析" aria-hidden="true" class="header-anchor">#</a> React redux源码解析</h1><h2 id="前言"><a href="#前言" aria-hidden="true" class="header-anchor">#</a> 前言</h2><p>React redux是一个将React与Redux关联的库，它由redux官方出品。</p><p>React redux在内部进行了各种解耦，因此扩展性强，并且通过缓存数据减少了不必要的re-render，具有很高的效率。</p><h2 id="selector"><a href="#selector" aria-hidden="true" class="header-anchor">#</a> Selector</h2><p><img src="/assets/img/1.74054717.png" alt><code>Selector</code>是一个函数，由<code>selectorFactory</code>得到。通过调用传入<code>SelectorFactory</code>的<code>mapStateToProps</code>，<code>mapDispatchToProps</code>，<code>mergeProps</code>，得到一个<code>finalProps</code>，并将它作为props注入到被<code>connect</code>的组件中。</p><p><code>mapStateToPropsFactories</code>，<code>mapDispatchToPropsFactories</code>，<code>mergePropsFactories</code>三个数组，每个数组里包含了若干个工厂方法，若<code>match</code>方法返回一个函数说明当前的<code>mapStateToProps</code>，<code>mapDispatchToProps</code>，<code>mergeProps</code>匹配上了数组中的某个工厂方法，这个匹配上的工厂方法会成为<code>initMapStateToProps</code>，<code>initMapDispatchToProps</code>，<code>initMergeProps</code></p><p>下面是<code>match</code>的实现</p><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">match</span><span class="token punctuation">(</span>arg<span class="token punctuation">,</span> factories<span class="token punctuation">,</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> factories<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> result <span class="token operator">=</span> factories<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span>

    <span class="token comment">// 匹配上了就返回这个initXXXXProps</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token keyword">return</span> result
  <span class="token punctuation">}</span>

  <span class="token comment">// 一个factory都匹配不上的时候，说明传入的`mapStateToProps`、`mapDispatchToProps`、`mergeProps`类型错误</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>dispatch<span class="token punctuation">,</span> options<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`Invalid value of type </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">typeof</span> arg<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> for </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> argument when connecting component </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>options<span class="token punctuation">.</span>wrappedComponentName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">.`</span></span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
</code></pre><p>这个<code>match</code>被这样使用</p><pre class="language-js"><code>    <span class="token keyword">const</span> initMapStateToProps <span class="token operator">=</span> <span class="token function">match</span><span class="token punctuation">(</span>mapStateToProps<span class="token punctuation">,</span> mapStateToPropsFactories<span class="token punctuation">,</span> <span class="token string">'mapStateToProps'</span><span class="token punctuation">)</span>
    <span class="token keyword">const</span> initMapDispatchToProps <span class="token operator">=</span> <span class="token function">match</span><span class="token punctuation">(</span>mapDispatchToProps<span class="token punctuation">,</span> mapDispatchToPropsFactories<span class="token punctuation">,</span> <span class="token string">'mapDispatchToProps'</span><span class="token punctuation">)</span>
    <span class="token keyword">const</span> initMergeProps <span class="token operator">=</span> <span class="token function">match</span><span class="token punctuation">(</span>mergeProps<span class="token punctuation">,</span> mergePropsFactories<span class="token punctuation">,</span> <span class="token string">'mergeProps'</span><span class="token punctuation">)</span>
</code></pre><p>在看三个工厂函数数组的实现之前，先看一下<code>wrapMapToPropsConstant</code>和<code>wrapMapToPropsFunc</code>的实现，因为最终的<code>initMapStateToProps</code>和<code>initDispatchToProps</code>都是由这两个函数其中之一返回的</p><h3 id="wrapmaptopropsconstant"><a href="#wrapmaptopropsconstant" aria-hidden="true" class="header-anchor">#</a> wrapMapToPropsConstant</h3><p>wrapMapToPropsConstant的返回值会在两种情况下成为<code>initXXXXXProps</code>：</p><ol><li><code>mapStateToProps</code>或者<code>mapDispatchToProps</code>参数缺失，这种情况下mapToProps会返回<code>{}</code></li><li><code>mapDispatchProps</code>传入了一个对象，这样的话，这个对象里的每个actionCreator都会被包裹，形如这样<code>(dispatch) =&gt; { foo: (...args) dispatch(foo(...args)) }</code>，这种情况下mapStateToProps每次调用也会返回一个常量（除非reducer被<code>replaceReducer整个替换掉</code>，不过这样的话<code>initXXXXProps</code>也会被重新调用了）</li></ol><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">wrapMapToPropsConstant</span><span class="token punctuation">(</span>getConstant<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">initConstantSelector</span><span class="token punctuation">(</span>dispatch<span class="token punctuation">,</span> options<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 调用`initXXXXToProps`时就会计算好这个要返回的常量</span>
    <span class="token keyword">const</span> constant <span class="token operator">=</span> <span class="token function">getConstant</span><span class="token punctuation">(</span>dispatch<span class="token punctuation">,</span> options<span class="token punctuation">)</span>

    <span class="token comment">// 然后mapStateToProps或mapDispatchToProps调用的时候会返回init执行时的constant的引用</span>
    <span class="token keyword">function</span> <span class="token function">constantSelector</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> constant <span class="token punctuation">}</span>
    <span class="token comment">// 告诉Selector,当State改变时，不需要更新我，直接用原来缓存的返回值</span>
    constantSelector<span class="token punctuation">.</span>dependsOnOwnProps <span class="token operator">=</span> <span class="token boolean">false</span>
    <span class="token keyword">return</span> constantSelector
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><h3 id="wrapmaptopropsfunc"><a href="#wrapmaptopropsfunc" aria-hidden="true" class="header-anchor">#</a> wrapMapToPropsFunc</h3><p>他会在下面2种情况下成为<code>initXXXXProps</code>：</p><ol><li><code>mapStateToProps</code>为函数</li><li><code>mapDispatchToProps</code>为函数</li></ol><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">wrapMapToPropsFunc</span><span class="token punctuation">(</span>mapToProps<span class="token punctuation">,</span> methodName<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">initProxySelector</span><span class="token punctuation">(</span>dispatch<span class="token punctuation">,</span> <span class="token punctuation">{</span> displayName <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token comment">// 将mapToProps代理到proxy上</span>
    <span class="token comment">// 当mapToProps依赖ownProps时，额外传入ownProps，否则只传入state或者dispatch</span>
    <span class="token keyword">const</span> <span class="token function-variable function">proxy</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">mapToPropsProxy</span><span class="token punctuation">(</span>stateOrDispatch<span class="token punctuation">,</span> ownProps<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> proxy<span class="token punctuation">.</span>dependsOnOwnProps
        <span class="token operator">?</span> proxy<span class="token punctuation">.</span><span class="token function">mapToProps</span><span class="token punctuation">(</span>stateOrDispatch<span class="token punctuation">,</span> ownProps<span class="token punctuation">)</span>
        <span class="token punctuation">:</span> proxy<span class="token punctuation">.</span><span class="token function">mapToProps</span><span class="token punctuation">(</span>stateOrDispatch<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// allow detectFactoryAndVerify to get ownProps</span>
    proxy<span class="token punctuation">.</span>dependsOnOwnProps <span class="token operator">=</span> <span class="token boolean">true</span>

    <span class="token comment">// 第一次通过代理执行mapToProps时会执行下列代码</span>
    proxy<span class="token punctuation">.</span><span class="token function-variable function">mapToProps</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">detectFactoryAndVerify</span><span class="token punctuation">(</span>stateOrDispatch<span class="token punctuation">,</span> ownProps<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 保证之后的`mapToProps`执行时不会执行`detectFactoryAndVerify`</span>
      proxy<span class="token punctuation">.</span>mapToProps <span class="token operator">=</span> mapToProps

      <span class="token comment">// 当mapToProps有dependsOnOwnProps属性时返回mapToProps.dependsOnOwnProps。</span>
      <span class="token comment">// 如果没有， 若函数参数个数为1返回false,否则返回true</span>
      proxy<span class="token punctuation">.</span>dependsOnOwnProps <span class="token operator">=</span> <span class="token function">getDependsOnOwnProps</span><span class="token punctuation">(</span>mapToProps<span class="token punctuation">)</span>

      <span class="token comment">// 得到下一个props</span>
      <span class="token keyword">let</span> props <span class="token operator">=</span> <span class="token function">proxy</span><span class="token punctuation">(</span>stateOrDispatch<span class="token punctuation">,</span> ownProps<span class="token punctuation">)</span>

      <span class="token comment">// 若props为柯里化函数递归调用proxy</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> props <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        proxy<span class="token punctuation">.</span>mapToProps <span class="token operator">=</span> props
        proxy<span class="token punctuation">.</span>dependsOnOwnProps <span class="token operator">=</span> <span class="token function">getDependsOnOwnProps</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span>
        props <span class="token operator">=</span> <span class="token function">proxy</span><span class="token punctuation">(</span>stateOrDispatch<span class="token punctuation">,</span> ownProps<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>

      <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span>
        <span class="token function">verifyPlainObject</span><span class="token punctuation">(</span>props<span class="token punctuation">,</span> displayName<span class="token punctuation">,</span> methodName<span class="token punctuation">)</span>

      <span class="token keyword">return</span> props
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> proxy
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><h3 id="mapstatetopropsfactories"><a href="#mapstatetopropsfactories" aria-hidden="true" class="header-anchor">#</a> mapStateToPropsFactories</h3><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> wrapMapToPropsConstant<span class="token punctuation">,</span> wrapMapToPropsFunc <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./wrapMapToProps'</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">whenMapStateToPropsIsFunction</span><span class="token punctuation">(</span>mapStateToProps<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 按照上面所说，mapState类型为函数时用wrapMapToPropsFunc构造initMapStateToProps</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> mapStateToProps <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span>
    <span class="token operator">?</span> <span class="token function">wrapMapToPropsFunc</span><span class="token punctuation">(</span>mapStateToProps<span class="token punctuation">,</span> <span class="token string">'mapStateToProps'</span><span class="token punctuation">)</span>
    <span class="token punctuation">:</span> undefined
<span class="token punctuation">}</span>
  <span class="token comment">// 否则用wrapMapToPropsConstant并传入一个空函数构造initMapStateToProps，这个initMapStateToProps会永远返回一个空的对象`{}`</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">whenMapStateToPropsIsMissing</span><span class="token punctuation">(</span>mapStateToProps<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">!</span>mapStateToProps<span class="token punctuation">)</span>
    <span class="token operator">?</span> <span class="token function">wrapMapToPropsConstant</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">:</span> undefined
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">[</span>
  whenMapStateToPropsIsFunction<span class="token punctuation">,</span>
  whenMapStateToPropsIsMissing
<span class="token punctuation">]</span>

</code></pre><h3 id="mapdispatchtopropsfactories"><a href="#mapdispatchtopropsfactories" aria-hidden="true" class="header-anchor">#</a> mapDispatchToPropsFactories</h3><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> bindActionCreators <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'redux'</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> wrapMapToPropsConstant<span class="token punctuation">,</span> wrapMapToPropsFunc <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./wrapMapToProps'</span>

<span class="token comment">// mapDispatchToProps类型是函数时使用wrapMapToPropsFunc的返回值作为initWrapMapToFunc</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">whenMapDispatchToPropsIsFunction</span><span class="token punctuation">(</span>mapDispatchToProps<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> mapDispatchToProps <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span>
    <span class="token operator">?</span> <span class="token function">wrapMapToPropsFunc</span><span class="token punctuation">(</span>mapDispatchToProps<span class="token punctuation">,</span> <span class="token string">'mapDispatchToProps'</span><span class="token punctuation">)</span>
    <span class="token punctuation">:</span> undefined
<span class="token punctuation">}</span>

<span class="token comment">// 缺失时，默认调用dispatchToProps会返回一个对象，对象里的dispatch字段即是store的dispatch方法</span>
<span class="token comment">// 通过后面的mergeToProps，这个dispatch最终能在组件中通过this.props.dispatch获得store的dispatch方法的引用</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">whenMapDispatchToPropsIsMissing</span><span class="token punctuation">(</span>mapDispatchToProps<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">!</span>mapDispatchToProps<span class="token punctuation">)</span>
    <span class="token operator">?</span> <span class="token function">wrapMapToPropsConstant</span><span class="token punctuation">(</span>dispatch <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> dispatch <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">:</span> undefined
<span class="token punctuation">}</span>
<span class="token comment">// mapDispatchToProps是一个对象且每个对象的value是Action creator时</span>
<span class="token comment">// 通过bindActionCreator将每个value变成这样的一个函数`(...args) =&gt; dispatch(fooActionCreator(...args))`</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">whenMapDispatchToPropsIsObject</span><span class="token punctuation">(</span>mapDispatchToProps<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>mapDispatchToProps <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> mapDispatchToProps <span class="token operator">===</span> <span class="token string">'object'</span><span class="token punctuation">)</span>
    <span class="token operator">?</span> <span class="token function">wrapMapToPropsConstant</span><span class="token punctuation">(</span>dispatch <span class="token operator">=&gt;</span> <span class="token function">bindActionCreators</span><span class="token punctuation">(</span>mapDispatchToProps<span class="token punctuation">,</span> dispatch<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">:</span> undefined
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">[</span>
  whenMapDispatchToPropsIsFunction<span class="token punctuation">,</span>
  whenMapDispatchToPropsIsMissing<span class="token punctuation">,</span>
  whenMapDispatchToPropsIsObject
<span class="token punctuation">]</span>
</code></pre><h3 id="mergepropsfactories"><a href="#mergepropsfactories" aria-hidden="true" class="header-anchor">#</a> mergePropsFactories</h3><pre class="language-js"><code><span class="token keyword">import</span> verifyPlainObject <span class="token keyword">from</span> <span class="token string">'../utils/verifyPlainObject'</span>

<span class="token comment">// 默认的mergeToProps，将`ownProps`，`stateProps`，`dispatchProps`合并到一个对象中作为最终的props</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">defaultMergeProps</span><span class="token punctuation">(</span>stateProps<span class="token punctuation">,</span> dispatchProps<span class="token punctuation">,</span> ownProps<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span> <span class="token operator">...</span>ownProps<span class="token punctuation">,</span> <span class="token operator">...</span>stateProps<span class="token punctuation">,</span> <span class="token operator">...</span>dispatchProps <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 当mergeProps为function时，用wrapMergePropsFunc的返回值，作为initMergeProps</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">wrapMergePropsFunc</span><span class="token punctuation">(</span>mergeProps<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">initMergePropsProxy</span><span class="token punctuation">(</span>
    dispatch<span class="token punctuation">,</span> <span class="token punctuation">{</span> displayName<span class="token punctuation">,</span> pure<span class="token punctuation">,</span> areMergedPropsEqual <span class="token punctuation">}</span>
  <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> hasRunOnce <span class="token operator">=</span> <span class="token boolean">false</span>
    <span class="token keyword">let</span> mergedProps

    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">mergePropsProxy</span><span class="token punctuation">(</span>stateProps<span class="token punctuation">,</span> dispatchProps<span class="token punctuation">,</span> ownProps<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> nextMergedProps <span class="token operator">=</span> <span class="token function">mergeProps</span><span class="token punctuation">(</span>stateProps<span class="token punctuation">,</span> dispatchProps<span class="token punctuation">,</span> ownProps<span class="token punctuation">)</span>
      <span class="token comment">// 获得下一个mergeProps</span>

      <span class="token comment">// 非第一次运行</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>hasRunOnce<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 当传入initMergePropsProxy的pure为false时每次调用mergeProps都会返回新的引用</span>
        <span class="token comment">// 或者当当前props和下一个props进行比较(默认是浅比较，由areMergedPropsEqual决定)不等时</span>
        <span class="token comment">// 将下一个props更新到当前的mergedProps</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>pure <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">areMergedPropsEqual</span><span class="token punctuation">(</span>nextMergedProps<span class="token punctuation">,</span> mergedProps<span class="token punctuation">)</span><span class="token punctuation">)</span>
          mergedProps <span class="token operator">=</span> nextMergedProps

      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        hasRunOnce <span class="token operator">=</span> <span class="token boolean">true</span>
        <span class="token comment">// 第一次运行时，mergedProps为undefined</span>
        mergedProps <span class="token operator">=</span> nextMergedProps

        <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span>
          <span class="token function">verifyPlainObject</span><span class="token punctuation">(</span>mergedProps<span class="token punctuation">,</span> displayName<span class="token punctuation">,</span> <span class="token string">'mergeProps'</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// 返回mergedProps，如果mergedProps没有改变，那么会返回之前的mergedProps的引用</span>
      <span class="token comment">// 这样当areMergedPropsEqual变为严格相等 (即用 === 比较)时能正确地工作</span>
      <span class="token keyword">return</span> mergedProps
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// mergeProps为函数时返回的initMergeProps</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">whenMergePropsIsFunction</span><span class="token punctuation">(</span>mergeProps<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> mergeProps <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span>
    <span class="token operator">?</span> <span class="token function">wrapMergePropsFunc</span><span class="token punctuation">(</span>mergeProps<span class="token punctuation">)</span>
    <span class="token punctuation">:</span> undefined
<span class="token punctuation">}</span>

<span class="token comment">// mergeProps缺失时返回默认的initMergeProps</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">whenMergePropsIsOmitted</span><span class="token punctuation">(</span>mergeProps<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">!</span>mergeProps<span class="token punctuation">)</span>
    <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> defaultMergeProps
    <span class="token punctuation">:</span> undefined
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">[</span>
  whenMergePropsIsFunction<span class="token punctuation">,</span>
  whenMergePropsIsOmitted
<span class="token punctuation">]</span>

</code></pre><h3 id="finalpropsselectorfactory"><a href="#finalpropsselectorfactory" aria-hidden="true" class="header-anchor">#</a> finalPropsSelectorFactory</h3><p>通过上面的<code>mapStateToPropsFactories</code>，<code>mapDispatchToPropsFactories</code>，<code>mergePropsFactories</code>，
我们得到了<code>initMapStateToProps</code>，<code>initMapDispatchToProps</code>, <code>initMergeProps</code>三个工厂函数。
这三个工厂函数最终会在<code>finalPropsSelectorFactory</code>中被调用</p><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">finalPropsSelectorFactory</span><span class="token punctuation">(</span>dispatch<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  initMapStateToProps<span class="token punctuation">,</span>
  initMapDispatchToProps<span class="token punctuation">,</span>
  initMergeProps<span class="token punctuation">,</span>
  <span class="token operator">...</span>options
<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 调用三个工厂函数，得到`mapStateToProps`，`mapDispatchToProps`，`mergeProps`</span>
  <span class="token keyword">const</span> mapStateToProps <span class="token operator">=</span> <span class="token function">initMapStateToProps</span><span class="token punctuation">(</span>dispatch<span class="token punctuation">,</span> options<span class="token punctuation">)</span>
  <span class="token keyword">const</span> mapDispatchToProps <span class="token operator">=</span> <span class="token function">initMapDispatchToProps</span><span class="token punctuation">(</span>dispatch<span class="token punctuation">,</span> options<span class="token punctuation">)</span>
  <span class="token keyword">const</span> mergeProps <span class="token operator">=</span> <span class="token function">initMergeProps</span><span class="token punctuation">(</span>dispatch<span class="token punctuation">,</span> options<span class="token punctuation">)</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">verifySubselectors</span><span class="token punctuation">(</span>mapStateToProps<span class="token punctuation">,</span> mapDispatchToProps<span class="token punctuation">,</span> mergeProps<span class="token punctuation">,</span> options<span class="token punctuation">.</span>displayName<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 当createConnect的pure选项为true时，</span>
  <span class="token comment">// React redux会缓存`mapStateToProps`，`mapDispatchToProps`，`mergeProps`的结果</span>
  <span class="token comment">// 减少不必要的re-render</span>
  <span class="token comment">// 这样做有利于性能的提高</span>
  <span class="token keyword">const</span> selectorFactory <span class="token operator">=</span> options<span class="token punctuation">.</span>pure
    <span class="token operator">?</span> pureFinalPropsSelectorFactory
    <span class="token punctuation">:</span> impureFinalPropsSelectorFactory

  <span class="token keyword">return</span> <span class="token function">selectorFactory</span><span class="token punctuation">(</span>
    mapStateToProps<span class="token punctuation">,</span>
    mapDispatchToProps<span class="token punctuation">,</span>
    mergeProps<span class="token punctuation">,</span>
    dispatch<span class="token punctuation">,</span>
    options
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>

</code></pre><h3 id="impurefinalpropsselectorfactory"><a href="#impurefinalpropsselectorfactory" aria-hidden="true" class="header-anchor">#</a> impureFinalPropsSelectorFactory</h3><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">impureFinalPropsSelectorFactory</span><span class="token punctuation">(</span>
  mapStateToProps<span class="token punctuation">,</span>
  mapDispatchToProps<span class="token punctuation">,</span>
  mergeProps<span class="token punctuation">,</span>
  dispatch
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">impureFinalPropsSelector</span><span class="token punctuation">(</span>state<span class="token punctuation">,</span> ownProps<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 当pure为false时，不对`mapStateToProps`，`mapDispatchToProps`, `mergeProps`结果做缓存</span>
    <span class="token comment">// 直接返回最终传给被connect包裹组件的props</span>
    <span class="token keyword">return</span> <span class="token function">mergeProps</span><span class="token punctuation">(</span>
      <span class="token function">mapStateToProps</span><span class="token punctuation">(</span>state<span class="token punctuation">,</span> ownProps<span class="token punctuation">)</span><span class="token punctuation">,</span>
      <span class="token function">mapDispatchToProps</span><span class="token punctuation">(</span>dispatch<span class="token punctuation">,</span> ownProps<span class="token punctuation">)</span><span class="token punctuation">,</span>
      ownProps
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><h3 id="purefinalpropsselectorfactory"><a href="#purefinalpropsselectorfactory" aria-hidden="true" class="header-anchor">#</a> pureFinalPropsSelectorFactory</h3><p>在这段代码下面，作者留了这样一段注释</p><pre class="language-js"><code><span class="token comment">// If pure is true, the selector returned by selectorFactory will memoize its results,</span>
<span class="token comment">// allowing connectAdvanced's shouldComponentUpdate to return false if final</span>
<span class="token comment">// props have not changed. If false, the selector will always return a new</span>
<span class="token comment">// object and shouldComponentUpdate will always return true.</span>
</code></pre><p>如果pure是true，那么selector将会缓存它自己的返回值，并且允许connectAdvanced 通过shouldComponentUpdate返回最终的props是否变化。
如果pure为false，<code>shouldComponentUpdate</code>会永远返回<code>true</code>。这样当store的state改变时，传给被Connect包裹的组件的props改变，组件就必定会re-render</p><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">pureFinalPropsSelectorFactory</span><span class="token punctuation">(</span>
  mapStateToProps<span class="token punctuation">,</span>
  mapDispatchToProps<span class="token punctuation">,</span>
  mergeProps<span class="token punctuation">,</span>
  dispatch<span class="token punctuation">,</span>
  <span class="token punctuation">{</span> areStatesEqual<span class="token punctuation">,</span> areOwnPropsEqual<span class="token punctuation">,</span> areStatePropsEqual <span class="token punctuation">}</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> hasRunAtLeastOnce <span class="token operator">=</span> <span class="token boolean">false</span>
  <span class="token keyword">let</span> state
  <span class="token keyword">let</span> ownProps
  <span class="token keyword">let</span> stateProps
  <span class="token keyword">let</span> dispatchProps
  <span class="token keyword">let</span> mergedProps

  <span class="token comment">// 当第一次调用selector时会执行这里的代码</span>
  <span class="token comment">// 计算props，存储在变量中，返回最终的props。</span>
  <span class="token keyword">function</span> <span class="token function">handleFirstCall</span><span class="token punctuation">(</span>firstState<span class="token punctuation">,</span> firstOwnProps<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    state <span class="token operator">=</span> firstState
    ownProps <span class="token operator">=</span> firstOwnProps
    stateProps <span class="token operator">=</span> <span class="token function">mapStateToProps</span><span class="token punctuation">(</span>state<span class="token punctuation">,</span> ownProps<span class="token punctuation">)</span>
    dispatchProps <span class="token operator">=</span> <span class="token function">mapDispatchToProps</span><span class="token punctuation">(</span>dispatch<span class="token punctuation">,</span> ownProps<span class="token punctuation">)</span>
    mergedProps <span class="token operator">=</span> <span class="token function">mergeProps</span><span class="token punctuation">(</span>stateProps<span class="token punctuation">,</span> dispatchProps<span class="token punctuation">,</span> ownProps<span class="token punctuation">)</span>
    hasRunAtLeastOnce <span class="token operator">=</span> <span class="token boolean">true</span>
    <span class="token keyword">return</span> mergedProps
  <span class="token punctuation">}</span>

  <span class="token comment">// state和ownProps都改变的时候</span>
  <span class="token keyword">function</span> <span class="token function">handleNewPropsAndNewState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 从state和ownProps得到新的stateProps</span>
    stateProps <span class="token operator">=</span> <span class="token function">mapStateToProps</span><span class="token punctuation">(</span>state<span class="token punctuation">,</span> ownProps<span class="token punctuation">)</span>

    <span class="token comment">// 仅当mapDispatchToProps具有第二个参数ownProps，才更新dispatchProps</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>mapDispatchToProps<span class="token punctuation">.</span>dependsOnOwnProps<span class="token punctuation">)</span>
      dispatchProps <span class="token operator">=</span> <span class="token function">mapDispatchToProps</span><span class="token punctuation">(</span>dispatch<span class="token punctuation">,</span> ownProps<span class="token punctuation">)</span>

    <span class="token comment">// 这里的更新mergedProps是必要的。因为ownProps变化后组件需要rerender。</span>
    <span class="token comment">// Connect组件中，会使用strictEqual来判断最终的finalProps是否相等以决定shouldComponentUpdate的值</span>
    <span class="token comment">// 因此必须返回一个新的引用使得组件更新</span>
    mergedProps <span class="token operator">=</span> <span class="token function">mergeProps</span><span class="token punctuation">(</span>stateProps<span class="token punctuation">,</span> dispatchProps<span class="token punctuation">,</span> ownProps<span class="token punctuation">)</span>
    <span class="token comment">// 返回最终的props</span>
    <span class="token keyword">return</span> mergedProps
  <span class="token punctuation">}</span>

  <span class="token keyword">function</span> <span class="token function">handleNewProps</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 仅仅当mapStateToProps依赖ownProps时更新stateProps</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>mapStateToProps<span class="token punctuation">.</span>dependsOnOwnProps<span class="token punctuation">)</span>
      stateProps <span class="token operator">=</span> <span class="token function">mapStateToProps</span><span class="token punctuation">(</span>state<span class="token punctuation">,</span> ownProps<span class="token punctuation">)</span>

    <span class="token comment">// 仅仅当mapDispatchToProps依赖ownProps时更新dispatchProps</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>mapDispatchToProps<span class="token punctuation">.</span>dependsOnOwnProps<span class="token punctuation">)</span>
      dispatchProps <span class="token operator">=</span> <span class="token function">mapDispatchToProps</span><span class="token punctuation">(</span>dispatch<span class="token punctuation">,</span> ownProps<span class="token punctuation">)</span>

    <span class="token comment">// 这里的更新mergedProps是必要的。因为ownProps变化后组件需要rerender。</span>
    <span class="token comment">// Connect组件中，会使用strictEqual来判断最终的finalProps是否相等以决定shouldComponentUpdate的值</span>
    <span class="token comment">// 因此必须返回一个新的引用使得组件更新</span>
    mergedProps <span class="token operator">=</span> <span class="token function">mergeProps</span><span class="token punctuation">(</span>stateProps<span class="token punctuation">,</span> dispatchProps<span class="token punctuation">,</span> ownProps<span class="token punctuation">)</span>
    <span class="token keyword">return</span> mergedProps
  <span class="token punctuation">}</span>

  <span class="token comment">// 仅仅当state改变而ownProps未改变时</span>
  <span class="token keyword">function</span> <span class="token function">handleNewState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">const</span> nextStateProps <span class="token operator">=</span> <span class="token function">mapStateToProps</span><span class="token punctuation">(</span>state<span class="token punctuation">,</span> ownProps<span class="token punctuation">)</span>
    <span class="token keyword">const</span> statePropsChanged <span class="token operator">=</span> <span class="token operator">!</span><span class="token function">areStatePropsEqual</span><span class="token punctuation">(</span>nextStateProps<span class="token punctuation">,</span> stateProps<span class="token punctuation">)</span>
    stateProps <span class="token operator">=</span> nextStateProps

    <span class="token comment">// 如果stateProps变化才会更新mergeProps</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>statePropsChanged<span class="token punctuation">)</span>
      mergedProps <span class="token operator">=</span> <span class="token function">mergeProps</span><span class="token punctuation">(</span>stateProps<span class="token punctuation">,</span> dispatchProps<span class="token punctuation">,</span> ownProps<span class="token punctuation">)</span>

    <span class="token comment">// 返回新的或者旧的megeProps。</span>
    <span class="token comment">// 返回旧的mergeProps时，组件的shouldComponentUpdate会为false，就不会rerender了。</span>
    <span class="token keyword">return</span> mergedProps
  <span class="token punctuation">}</span>

  <span class="token comment">// 第一次调用selector之后再调用selector会执行这个函数</span>
  <span class="token keyword">function</span> <span class="token function">handleSubsequentCalls</span><span class="token punctuation">(</span>nextState<span class="token punctuation">,</span> nextOwnProps<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> propsChanged <span class="token operator">=</span> <span class="token operator">!</span><span class="token function">areOwnPropsEqual</span><span class="token punctuation">(</span>nextOwnProps<span class="token punctuation">,</span> ownProps<span class="token punctuation">)</span>
    <span class="token keyword">const</span> stateChanged <span class="token operator">=</span> <span class="token operator">!</span><span class="token function">areStatesEqual</span><span class="token punctuation">(</span>nextState<span class="token punctuation">,</span> state<span class="token punctuation">)</span>
    state <span class="token operator">=</span> nextState
    ownProps <span class="token operator">=</span> nextOwnProps

    <span class="token keyword">if</span> <span class="token punctuation">(</span>propsChanged <span class="token operator">&amp;&amp;</span> stateChanged<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">handleNewPropsAndNewState</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>propsChanged<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">handleNewProps</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>stateChanged<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">handleNewState</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// state和ownProps都没有变化时返回旧的mergedProps，这样被Connect包裹的组件就不会更新</span>
    <span class="token keyword">return</span> mergedProps
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">pureFinalPropsSelector</span><span class="token punctuation">(</span>nextState<span class="token punctuation">,</span> nextOwnProps<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> hasRunAtLeastOnce
      <span class="token operator">?</span> <span class="token function">handleSubsequentCalls</span><span class="token punctuation">(</span>nextState<span class="token punctuation">,</span> nextOwnProps<span class="token punctuation">)</span>
      <span class="token punctuation">:</span> <span class="token function">handleFirstCall</span><span class="token punctuation">(</span>nextState<span class="token punctuation">,</span> nextOwnProps<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><h2 id="provider组件"><a href="#provider组件" aria-hidden="true" class="header-anchor">#</a> Provider组件</h2><p>这个组件包裹在所有需要读取redux store组件的最外围。目的是通过React legacy context，使得被<code>Provider</code>包裹的组件可以通过context取得store的state和subscription。</p><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> Component<span class="token punctuation">,</span> Children <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react'</span>
<span class="token keyword">import</span> PropTypes <span class="token keyword">from</span> <span class="token string">'prop-types'</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> storeShape<span class="token punctuation">,</span> subscriptionShape <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'../utils/PropTypes'</span>
<span class="token keyword">import</span> warning <span class="token keyword">from</span> <span class="token string">'../utils/warning'</span>

<span class="token keyword">let</span> didWarnAboutReceivingStore <span class="token operator">=</span> <span class="token boolean">false</span>
<span class="token keyword">function</span> <span class="token function">warnAboutReceivingStore</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>didWarnAboutReceivingStore<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span>
  <span class="token punctuation">}</span>
  didWarnAboutReceivingStore <span class="token operator">=</span> <span class="token boolean">true</span>

  <span class="token function">warning</span><span class="token punctuation">(</span>
    <span class="token string">'&lt;Provider&gt; does not support changing `store` on the fly. '</span> <span class="token operator">+</span>
    <span class="token string">'It is most likely that you see this error because you updated to '</span> <span class="token operator">+</span>
    <span class="token string">'Redux 2.x and React Redux 2.x which no longer hot reload reducers '</span> <span class="token operator">+</span>
    <span class="token string">'automatically. See https://github.com/reduxjs/react-redux/releases/'</span> <span class="token operator">+</span>
    <span class="token string">'tag/v2.0.0 for the migration instructions.'</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">createProvider</span><span class="token punctuation">(</span>storeKey <span class="token operator">=</span> <span class="token string">'store'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> subscriptionKey <span class="token operator">=</span> <span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>storeKey<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">Subscription`</span></span>

    <span class="token keyword">class</span> <span class="token class-name">Provider</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>
      <span class="token comment">// 子组件可以通过指定context type来取得store和subscription</span>
        <span class="token function">getChildContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">return</span> <span class="token punctuation">{</span> <span class="token punctuation">[</span>storeKey<span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">[</span>storeKey<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>subscriptionKey<span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token keyword">null</span> <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

      <span class="token comment">// 因为用法是`&lt;Provider store={store}&gt;&lt;Foo /&gt;&lt;/Provider&gt;`</span>
      <span class="token comment">// 所以将props的store引用绑定到this上</span>
        <span class="token function">constructor</span><span class="token punctuation">(</span>props<span class="token punctuation">,</span> context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">,</span> context<span class="token punctuation">)</span>
          <span class="token keyword">this</span><span class="token punctuation">[</span>storeKey<span class="token punctuation">]</span> <span class="token operator">=</span> props<span class="token punctuation">.</span>store<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// 断言组件Children是单个组件</span>
          <span class="token keyword">return</span> Children<span class="token punctuation">.</span><span class="token function">only</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>children<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 和旧版本兼容需要做的判断</span>
      Provider<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">componentWillReceiveProps</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>nextProps<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">[</span>storeKey<span class="token punctuation">]</span> <span class="token operator">!==</span> nextProps<span class="token punctuation">.</span>store<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token function">warnAboutReceivingStore</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 自己的PropTypes</span>
    Provider<span class="token punctuation">.</span>propTypes <span class="token operator">=</span> <span class="token punctuation">{</span>
        store<span class="token punctuation">:</span> storeShape<span class="token punctuation">.</span>isRequired<span class="token punctuation">,</span>
        children<span class="token punctuation">:</span> PropTypes<span class="token punctuation">.</span>element<span class="token punctuation">.</span>isRequired<span class="token punctuation">,</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Children的contextTypes，只有`childContextTypes`和`getChildContext`在一个组件中同时存在</span>
    <span class="token comment">// React才会将这些信息给所有的子组件</span>
    Provider<span class="token punctuation">.</span>childContextTypes <span class="token operator">=</span> <span class="token punctuation">{</span>
        <span class="token punctuation">[</span>storeKey<span class="token punctuation">]</span><span class="token punctuation">:</span> storeShape<span class="token punctuation">.</span>isRequired<span class="token punctuation">,</span>
        <span class="token punctuation">[</span>subscriptionKey<span class="token punctuation">]</span><span class="token punctuation">:</span> subscriptionShape<span class="token punctuation">,</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> Provider
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token function">createProvider</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><h2 id="subscription"><a href="#subscription" aria-hidden="true" class="header-anchor">#</a> Subscription</h2><p>这部分在Redux自身的listener的基础上又包了一层自己的listener
保证祖先会比后代组件先渲染
Subscription上的订阅通过addNestedSubscribe，
最外层Connect组件上添加自身的this.onStateChange，
其后的子孙Connect组件上Subscription调用trySubscribe时，它们的onStateChange都会被
添加到他们的父listener上。这样的话。当store的state改变时，会先调用最外层的onStateChange。
之后，从最外层的Subscription开始，依次调用它们子组件的onStateChange，保证当state改变后组件是从最外层
开始更新的</p><pre class="language-js"><code><span class="token comment">// encapsulates the subscription logic for connecting a component to the redux store, as</span>
<span class="token comment">// well as nesting subscriptions of descendant components, so that we can ensure the</span>
<span class="token comment">// ancestor components re-render before descendants</span>

<span class="token keyword">const</span> <span class="token constant">CLEARED</span> <span class="token operator">=</span> <span class="token keyword">null</span>
<span class="token keyword">const</span> nullListeners <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span>
<span class="token comment">// 组件被卸载之后组件仍然调用`notifyNestedSubs`时的情况</span>

<span class="token keyword">function</span> <span class="token function">createListenerCollection</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// the current/next pattern is copied from redux's createStore code.</span>
  <span class="token comment">// TODO: refactor+expose that code to be reusable here?</span>
  <span class="token keyword">let</span> current <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token keyword">let</span> next <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      next <span class="token operator">=</span> <span class="token constant">CLEARED</span>
      current <span class="token operator">=</span> <span class="token constant">CLEARED</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>

    <span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 这部分逻辑是和redux中一样的。依次调用每个listener</span>
      <span class="token comment">// 因为Redux限制了在notify过程中listener改变时，对Listener的改变直到下一次notify才会生效</span>
      <span class="token keyword">const</span> listeners <span class="token operator">=</span> current <span class="token operator">=</span> next
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> listeners<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        listeners<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>

    <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> next
    <span class="token punctuation">}</span><span class="token punctuation">,</span>

    <span class="token function">subscribe</span><span class="token punctuation">(</span>listener<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">let</span> isSubscribed <span class="token operator">=</span> <span class="token boolean">true</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">===</span> current<span class="token punctuation">)</span> next <span class="token operator">=</span> current<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      next<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>listener<span class="token punctuation">)</span>
      
      <span class="token comment">// subscribe返回unsubscribe函数，逻辑和redux一样</span>
      <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">unsubscribe</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isSubscribed <span class="token operator">||</span> current <span class="token operator">===</span> <span class="token constant">CLEARED</span><span class="token punctuation">)</span> <span class="token keyword">return</span>
        isSubscribed <span class="token operator">=</span> <span class="token boolean">false</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">===</span> current<span class="token punctuation">)</span> next <span class="token operator">=</span> current<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        next<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>next<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>listener<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">Subscription</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span>store<span class="token punctuation">,</span> parentSub<span class="token punctuation">,</span> onStateChange<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>store <span class="token operator">=</span> store
    <span class="token keyword">this</span><span class="token punctuation">.</span>parentSub <span class="token operator">=</span> parentSub
    <span class="token keyword">this</span><span class="token punctuation">.</span>onStateChange <span class="token operator">=</span> onStateChange

    <span class="token comment">// 当Subcription订阅后，Listener的unsubscribe函数会被绑定到这个变量上</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>unsubscribe <span class="token operator">=</span> <span class="token keyword">null</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>listeners <span class="token operator">=</span> nullListeners
  <span class="token punctuation">}</span>

  <span class="token comment">// 后代的listener会最终订阅到他的父Subscription上</span>
  <span class="token comment">// 当store中的state更新后，会先调用父组件的onStateChange再调用子组件的onStateChange</span>
  <span class="token function">addNestedSub</span><span class="token punctuation">(</span>listener<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">trySubscribe</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>listeners<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span>listener<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token function">notifyNestedSubs</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>listeners<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token function">isSubscribed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">Boolean</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>unsubscribe<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token function">trySubscribe</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 当前subscribe没有订阅时</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>unsubscribe<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 将取消这个订阅的函数绑定到this.unsubscribe上</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>unsubscribe <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>parentSub
        <span class="token operator">?</span> <span class="token keyword">this</span><span class="token punctuation">.</span>parentSub<span class="token punctuation">.</span><span class="token function">addNestedSub</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>onStateChange<span class="token punctuation">)</span>
        <span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>store<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>onStateChange<span class="token punctuation">)</span>
      <span class="token comment">// 如果有父subscribe，则将onStateChange订阅到父SubScription上</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>listeners <span class="token operator">=</span> <span class="token function">createListenerCollection</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token function">tryUnsubscribe</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 取消订阅</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>unsubscribe<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">unsubscribe</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>unsubscribe <span class="token operator">=</span> <span class="token keyword">null</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>listeners<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>listeners <span class="token operator">=</span> nullListeners
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre><h2 id="connect"><a href="#connect" aria-hidden="true" class="header-anchor">#</a> connect</h2><p>通过connect函数，会返回一个高阶组件，调用这个高阶组件会返回Connect组件</p><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">noop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment">// 这个函数的作用是每次调用selector的时候保存当前当前的props，并与上次的props做strict equal</span>
<span class="token comment">// 当相等时，将shouldComponentUpdate设置为比较的结果。</span>
<span class="token comment">// Connect组件的shouldComponentUpdate返回了了selector的shouldComponentUpdate</span>
<span class="token comment">// 这样可以减少不必要的rerender</span>
<span class="token keyword">function</span> <span class="token function">makeSelectorStateful</span><span class="token punctuation">(</span>sourceSelector<span class="token punctuation">,</span> store<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// wrap the selector in an object that tracks its results between runs.</span>
  <span class="token keyword">const</span> selector <span class="token operator">=</span> <span class="token punctuation">{</span>
    run<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token function">runComponentSelector</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> nextProps <span class="token operator">=</span> <span class="token function">sourceSelector</span><span class="token punctuation">(</span>store<span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> props<span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>nextProps <span class="token operator">!==</span> selector<span class="token punctuation">.</span>props <span class="token operator">||</span> selector<span class="token punctuation">.</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          selector<span class="token punctuation">.</span>shouldComponentUpdate <span class="token operator">=</span> <span class="token boolean">true</span>
          selector<span class="token punctuation">.</span>props <span class="token operator">=</span> nextProps
          selector<span class="token punctuation">.</span>error <span class="token operator">=</span> <span class="token keyword">null</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        selector<span class="token punctuation">.</span>shouldComponentUpdate <span class="token operator">=</span> <span class="token boolean">true</span>
        selector<span class="token punctuation">.</span>error <span class="token operator">=</span> error
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> selector
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">connectAdvanced</span><span class="token punctuation">(</span>
  <span class="token comment">/*
    selectorFactory is a func that is responsible for returning the selector function used to
    compute new props from state, props, and dispatch. For example:

      export default connectAdvanced((dispatch, options) =&gt; (state, props) =&gt; ({
        thing: state.things[props.thingId],
        saveThing: fields =&gt; dispatch(actionCreators.saveThing(props.thingId, fields)),
      }))(YourComponent)

    Access to dispatch is provided to the factory so selectorFactories can bind actionCreators
    outside of their selector as an optimization. Options passed to connectAdvanced are passed to
    the selectorFactory, along with displayName and WrappedComponent, as the second argument.

    Note that selectorFactory is responsible for all caching/memoization of inbound and outbound
    props. Do not use connectAdvanced directly without memoizing results between calls to your
    selector, otherwise the Connect component will re-render on every state or props change.
  */</span>
  selectorFactory<span class="token punctuation">,</span>
  <span class="token comment">// options object:</span>
  <span class="token punctuation">{</span>
    <span class="token comment">// the func used to compute this HOC's displayName from the wrapped component's displayName.</span>
    <span class="token comment">// probably overridden by wrapper functions such as connect()</span>
    <span class="token function-variable function">getDisplayName</span> <span class="token operator">=</span> name <span class="token operator">=&gt;</span> <span class="token template-string"><span class="token string">`ConnectAdvanced(</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">)`</span></span><span class="token punctuation">,</span>

    <span class="token comment">// shown in error messages</span>
    <span class="token comment">// probably overridden by wrapper functions such as connect()</span>
    methodName <span class="token operator">=</span> <span class="token string">'connectAdvanced'</span><span class="token punctuation">,</span>

    <span class="token comment">// if defined, the name of the property passed to the wrapped element indicating the number of</span>
    <span class="token comment">// calls to render. useful for watching in react devtools for unnecessary re-renders.</span>
    renderCountProp <span class="token operator">=</span> undefined<span class="token punctuation">,</span>

    <span class="token comment">// determines whether this HOC subscribes to store changes</span>
    shouldHandleStateChanges <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">,</span>

    <span class="token comment">// the key of props/context to get the store</span>
    storeKey <span class="token operator">=</span> <span class="token string">'store'</span><span class="token punctuation">,</span>

    <span class="token comment">// if true, the wrapped element is exposed by this HOC via the getWrappedInstance() function.</span>
    withRef <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">,</span>

    <span class="token comment">// additional options are passed through to the selectorFactory</span>
    <span class="token operator">...</span>connectOptions
  <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> subscriptionKey <span class="token operator">=</span> storeKey <span class="token operator">+</span> <span class="token string">'Subscription'</span>
  <span class="token keyword">const</span> version <span class="token operator">=</span> hotReloadingVersion<span class="token operator">++</span>

  <span class="token keyword">const</span> contextTypes <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">[</span>storeKey<span class="token punctuation">]</span><span class="token punctuation">:</span> storeShape<span class="token punctuation">,</span>
    <span class="token punctuation">[</span>subscriptionKey<span class="token punctuation">]</span><span class="token punctuation">:</span> subscriptionShape<span class="token punctuation">,</span>
  <span class="token punctuation">}</span> <span class="token comment">// 接收Prodiver的contextTypes</span>


  <span class="token comment">// Connect提供了</span>
  <span class="token keyword">const</span> childContextTypes <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">[</span>subscriptionKey<span class="token punctuation">]</span><span class="token punctuation">:</span> subscriptionShape<span class="token punctuation">,</span>
  <span class="token punctuation">}</span>


  <span class="token comment">// 返回一高阶组件`wrapWithConnect`</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">wrapWithConnect</span><span class="token punctuation">(</span>WrappedComponent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">invariant</span><span class="token punctuation">(</span>
      <span class="token keyword">typeof</span> WrappedComponent <span class="token operator">==</span> <span class="token string">'function'</span><span class="token punctuation">,</span>
      <span class="token template-string"><span class="token string">`You must pass a component to the function returned by `</span></span> <span class="token operator">+</span>
      <span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>methodName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">. Instead received </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>WrappedComponent<span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span>
    <span class="token punctuation">)</span>

    <span class="token keyword">const</span> wrappedComponentName <span class="token operator">=</span> WrappedComponent<span class="token punctuation">.</span>displayName
      <span class="token operator">||</span> WrappedComponent<span class="token punctuation">.</span>name
      <span class="token operator">||</span> <span class="token string">'Component'</span>

    <span class="token comment">// 组件的dispayName,安装React dev tool后可以在Chrome的调试工具中看到</span>
    <span class="token keyword">const</span> displayName <span class="token operator">=</span> <span class="token function">getDisplayName</span><span class="token punctuation">(</span>wrappedComponentName<span class="token punctuation">)</span>

    <span class="token keyword">const</span> selectorFactoryOptions <span class="token operator">=</span> <span class="token punctuation">{</span>
      <span class="token operator">...</span>connectOptions<span class="token punctuation">,</span>
      getDisplayName<span class="token punctuation">,</span>
      methodName<span class="token punctuation">,</span>
      renderCountProp<span class="token punctuation">,</span>
      shouldHandleStateChanges<span class="token punctuation">,</span>
      storeKey<span class="token punctuation">,</span>
      withRef<span class="token punctuation">,</span>
      displayName<span class="token punctuation">,</span>
      wrappedComponentName<span class="token punctuation">,</span>
      WrappedComponent
    <span class="token punctuation">}</span>

    <span class="token comment">// TODO Actually fix our use of componentWillReceiveProps</span>
    <span class="token comment">/* eslint-disable react/no-deprecated */</span>

    <span class="token keyword">class</span> <span class="token class-name">Connect</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>
      <span class="token function">constructor</span><span class="token punctuation">(</span>props<span class="token punctuation">,</span> context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">,</span> context<span class="token punctuation">)</span>

        <span class="token keyword">this</span><span class="token punctuation">.</span>version <span class="token operator">=</span> version
        <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>renderCount <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token comment">// 为何从props获得store引用，原因不明</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>store <span class="token operator">=</span> props<span class="token punctuation">[</span>storeKey<span class="token punctuation">]</span> <span class="token operator">||</span> context<span class="token punctuation">[</span>storeKey<span class="token punctuation">]</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>propsMode <span class="token operator">=</span> <span class="token function">Boolean</span><span class="token punctuation">(</span>props<span class="token punctuation">[</span>storeKey<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>setWrappedInstance <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>setWrappedInstance<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>

        <span class="token function">invariant</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>store<span class="token punctuation">,</span>
          <span class="token template-string"><span class="token string">`Could not find &quot;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>storeKey<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&quot; in either the context or props of `</span></span> <span class="token operator">+</span>
          <span class="token template-string"><span class="token string">`&quot;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>displayName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&quot;. Either wrap the root component in a &lt;Provider&gt;, `</span></span> <span class="token operator">+</span>
          <span class="token template-string"><span class="token string">`or explicitly pass &quot;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>storeKey<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&quot; as a prop to &quot;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>displayName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&quot;.`</span></span>
        <span class="token punctuation">)</span>


        <span class="token comment">// 初始化selector</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">initSelector</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">initSubscription</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>

      <span class="token function">getChildContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// If this component received store from props, its subscription should be transparent</span>
        <span class="token comment">// to any descendants receiving store+subscription from context; it passes along</span>
        <span class="token comment">// subscription passed to it. Otherwise, it shadows the parent subscription, which allows</span>
        <span class="token comment">// Connect to control ordering of notifications to flow top-down.</span>
        <span class="token keyword">const</span> subscription <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>propsMode <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>subscription
        <span class="token keyword">return</span> <span class="token punctuation">{</span> <span class="token punctuation">[</span>subscriptionKey<span class="token punctuation">]</span><span class="token punctuation">:</span> subscription <span class="token operator">||</span> <span class="token keyword">this</span><span class="token punctuation">.</span>context<span class="token punctuation">[</span>subscriptionKey<span class="token punctuation">]</span> <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>

      <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>shouldHandleStateChanges<span class="token punctuation">)</span> <span class="token keyword">return</span>

        <span class="token comment">// componentWillMount fires during server side rendering, but componentDidMount and</span>
        <span class="token comment">// componentWillUnmount do not. Because of this, trySubscribe happens during ...didMount.</span>
        <span class="token comment">// Otherwise, unsubscription would never take place during SSR, causing a memory leak.</span>
        <span class="token comment">// To handle the case where a child component may have triggered a state change by</span>
        <span class="token comment">// dispatching an action in its componentWillMount, we have to re-run the select and maybe</span>
        <span class="token comment">// re-render.</span>
        <span class="token comment">// Store的订阅在服务端渲染中是不需要的。DidMount只会在浏览器上渲染时执行</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>subscription<span class="token punctuation">.</span><span class="token function">trySubscribe</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token comment">// 有时候可能在componentWillMount中dispatch Action导致State被改变</span>
        <span class="token comment">// 所以需要重新run一遍slector来获得新的props并决定是否需要更新组件</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>selector<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>selector<span class="token punctuation">.</span>shouldComponentUpdate<span class="token punctuation">)</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">forceUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>

      <span class="token comment">// 当下一个ownProps改变的时候，重新执行selctor生成新的props</span>
      <span class="token function">componentWillReceiveProps</span><span class="token punctuation">(</span>nextProps<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>selector<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>nextProps<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>

      <span class="token comment">// 如上面所说，每次执行selector.run都会比较这次和上次selector返回的结果</span>
      <span class="token comment">// 并把结果保存在selector.shouldComponentUpdate中</span>
      <span class="token comment">// Connect的shouldComponentUpdate通过返回selector.shouldComponentUpdate来决定组件是否更新</span>
      <span class="token function">shouldComponentUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>selector<span class="token punctuation">.</span>shouldComponentUpdate
      <span class="token punctuation">}</span>

      <span class="token comment">// 组件卸载的时候做的一些善后工作</span>
      <span class="token function">componentWillUnmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>subscription<span class="token punctuation">)</span> <span class="token keyword">this</span><span class="token punctuation">.</span>subscription<span class="token punctuation">.</span><span class="token function">tryUnsubscribe</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>subscription <span class="token operator">=</span> <span class="token keyword">null</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>notifyNestedSubs <span class="token operator">=</span> noop
        <span class="token keyword">this</span><span class="token punctuation">.</span>store <span class="token operator">=</span> <span class="token keyword">null</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>selector<span class="token punctuation">.</span>run <span class="token operator">=</span> noop
        <span class="token keyword">this</span><span class="token punctuation">.</span>selector<span class="token punctuation">.</span>shouldComponentUpdate <span class="token operator">=</span> <span class="token boolean">false</span>
      <span class="token punctuation">}</span>

      <span class="token function">getWrappedInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">invariant</span><span class="token punctuation">(</span>withRef<span class="token punctuation">,</span>
          <span class="token template-string"><span class="token string">`To access the wrapped instance, you need to specify `</span></span> <span class="token operator">+</span>
          <span class="token template-string"><span class="token string">`{ withRef: true } in the options argument of the </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>methodName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">() call.`</span></span>
        <span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>wrappedInstance
      <span class="token punctuation">}</span>

      <span class="token comment">// 通过ref到Connect上再调用this.ref.xxx.setWrappedInstance能获得这个被包裹组件的引用</span>
      <span class="token comment">// React 16.3的forwardRef可以替代这个问题，让connect的ref指向被包裹的组件</span>
      <span class="token function">setWrappedInstance</span><span class="token punctuation">(</span>ref<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>wrappedInstance <span class="token operator">=</span> ref
      <span class="token punctuation">}</span>

      <span class="token comment">// 初始化selector</span>
      <span class="token comment">// selector的作用有</span>
      <span class="token comment">// 1. 调用selector.run，当组件更新时，获得下一个props</span>
      <span class="token comment">// 2. 通过selector.shouldComponentUpdate判断组件是否需要更新</span>
      <span class="token function">initSelector</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> sourceSelector <span class="token operator">=</span> <span class="token function">selectorFactory</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>store<span class="token punctuation">.</span>dispatch<span class="token punctuation">,</span> selectorFactoryOptions<span class="token punctuation">)</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>selector <span class="token operator">=</span> <span class="token function">makeSelectorStateful</span><span class="token punctuation">(</span>sourceSelector<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>store<span class="token punctuation">)</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>selector<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>

      <span class="token function">initSubscription</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>shouldHandleStateChanges<span class="token punctuation">)</span> <span class="token keyword">return</span>

        <span class="token comment">// parentSub's source should match where store came from: props vs. context. A component</span>
        <span class="token comment">// connected to the store via props shouldn't use subscription from context, or vice versa.</span>
        <span class="token comment">// 组件通过props来访问到store的时候是不应该访问到subscription的。</span>
        <span class="token keyword">const</span> parentSub <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>propsMode <span class="token operator">?</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props <span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>context<span class="token punctuation">)</span><span class="token punctuation">[</span>subscriptionKey<span class="token punctuation">]</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>subscription <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Subscription</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>store<span class="token punctuation">,</span> parentSub<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>onStateChange<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

        <span class="token comment">// `notifyNestedSubs` is duplicated to handle the case where the component is  unmounted in</span>
        <span class="token comment">// the middle of the notification loop, where `this.subscription` will then be null. An</span>
        <span class="token comment">// extra null check every change can be avoided by copying the method onto `this` and then</span>
        <span class="token comment">// replacing it with a no-op on unmount. This can probably be avoided if Subscription's</span>
        <span class="token comment">// listeners logic is changed to not call listeners that have been unsubscribed in the</span>
        <span class="token comment">// middle of the notification loop.</span>
        <span class="token comment">// 当发布订阅消息的过程中可能组件被卸载，那样的话this.subscription为null。</span>
        <span class="token comment">// ,将this.subscription bind到notifyNestedSubs上可以避免每次执行notifyNestedSubs判断this是否为null</span>
        <span class="token comment">// 当组件被卸载后，subscription会执行空函数。</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>notifyNestedSubs <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>subscription<span class="token punctuation">.</span>notifyNestedSubs<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>subscription<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>

      <span class="token comment">// 当store的state改变时会调用这个函数</span>
      <span class="token function">onStateChange</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 重新用selector获取props</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>selector<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">)</span>

        <span class="token comment">// 组件不更新的情况 </span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>selector<span class="token punctuation">.</span>shouldComponentUpdate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">notifyNestedSubs</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
          <span class="token comment">//执行listener</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>

          <span class="token keyword">this</span><span class="token punctuation">.</span>componentDidUpdate <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>notifyNestedSubsOnComponentDidUpdate
          <span class="token comment">// 通过setState来触发组件更新</span>
          <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span>dummyState<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>

      <span class="token function">notifyNestedSubsOnComponentDidUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// `componentDidUpdate` is conditionally implemented when `onStateChange` determines it</span>
        <span class="token comment">// needs to notify nested subs. Once called, it unimplements itself until further state</span>
        <span class="token comment">// changes occur. Doing it this way vs having a permanent `componentDidUpdate` that does</span>
        <span class="token comment">// a boolean check every time avoids an extra method call most of the time, resulting</span>
        <span class="token comment">// in some perf boost.</span>
        <span class="token comment">// 比起每次都在componentDidUpdate里判断是否是onStateChange导致的更新，这种方法更高效</span>
        <span class="token comment">// 只有由于onStateChange导致的更新才会去通知listener。其它情况下不会执行他</span>
        <span class="token comment">// 还有这种操作.jpg</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>componentDidUpdate <span class="token operator">=</span> undefined
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">notifyNestedSubs</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>

      <span class="token function">isSubscribed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">Boolean</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>subscription<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>subscription<span class="token punctuation">.</span><span class="token function">isSubscribed</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>

      <span class="token function">addExtraProps</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>withRef <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>renderCountProp <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>propsMode <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>subscription<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> props
        <span class="token comment">// make a shallow copy so that fields added don't leak to the original selector.</span>
        <span class="token comment">// this is especially important for 'ref' since that's a reference back to the component</span>
        <span class="token comment">// instance. a singleton memoized selector would then be holding a reference to the</span>
        <span class="token comment">// instance, preventing the instance from being garbage collected, and that would be bad</span>
        <span class="token comment">// 做一个浅拷贝，让外部通过ref引用selector时，不会出现selector缺失的情况（组件被卸载，然后Connect</span>
        <span class="token comment">// 的selector引用被设置为null）</span>
        <span class="token comment">// 一个缓存selector的单例会保持对组件实例的引用，这样组件实例会无法被垃圾回收</span>
        <span class="token comment">// emmm让我想想这怎么实现</span>
        <span class="token keyword">const</span> withExtras <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">...</span>props <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>withRef<span class="token punctuation">)</span> withExtras<span class="token punctuation">.</span>ref <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>setWrappedInstance
        <span class="token keyword">if</span> <span class="token punctuation">(</span>renderCountProp<span class="token punctuation">)</span> withExtras<span class="token punctuation">[</span>renderCountProp<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>renderCount<span class="token operator">++</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>propsMode <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>subscription<span class="token punctuation">)</span> withExtras<span class="token punctuation">[</span>subscriptionKey<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>subscription
        <span class="token keyword">return</span> withExtras
      <span class="token punctuation">}</span>

      <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> selector <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>selector
        selector<span class="token punctuation">.</span>shouldComponentUpdate <span class="token operator">=</span> <span class="token boolean">false</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>selector<span class="token punctuation">.</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">throw</span> selector<span class="token punctuation">.</span>error
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
          <span class="token keyword">return</span> <span class="token function">createElement</span><span class="token punctuation">(</span>WrappedComponent<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">addExtraProps</span><span class="token punctuation">(</span>selector<span class="token punctuation">.</span>props<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/* eslint-enable react/no-deprecated */</span>
    <span class="token comment">// 将一些东西绑定到Connect的static filed上</span>
    <span class="token comment">// 比如contextTypes</span>
    Connect<span class="token punctuation">.</span>WrappedComponent <span class="token operator">=</span> WrappedComponent
    Connect<span class="token punctuation">.</span>displayName <span class="token operator">=</span> displayName
    Connect<span class="token punctuation">.</span>childContextTypes <span class="token operator">=</span> childContextTypes
    Connect<span class="token punctuation">.</span>contextTypes <span class="token operator">=</span> contextTypes
    Connect<span class="token punctuation">.</span>propTypes <span class="token operator">=</span> contextTypes

    <span class="token comment">// 热重载的情况下重新初始化listener</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      Connect<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">componentWillUpdate</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">componentWillUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// We are hot reloading!</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>version <span class="token operator">!==</span> version<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">this</span><span class="token punctuation">.</span>version <span class="token operator">=</span> version
          <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">initSelector</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

          <span class="token comment">// If any connected descendants don't hot reload (and resubscribe in the process), their</span>
          <span class="token comment">// listeners will be lost when we unsubscribe. Unfortunately, by copying over all</span>
          <span class="token comment">// listeners, this does mean that the old versions of connected descendants will still be</span>
          <span class="token comment">// notified of state changes; however, their onStateChange function is a no-op so this</span>
          <span class="token comment">// isn't a huge deal.</span>
          <span class="token keyword">let</span> oldListeners <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

          <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>subscription<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            oldListeners <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>subscription<span class="token punctuation">.</span>listeners<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>subscription<span class="token punctuation">.</span><span class="token function">tryUnsubscribe</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
          <span class="token punctuation">}</span>
          <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">initSubscription</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span>shouldHandleStateChanges<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>subscription<span class="token punctuation">.</span><span class="token function">trySubscribe</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            oldListeners<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>listener <span class="token operator">=&gt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>subscription<span class="token punctuation">.</span>listeners<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span>listener<span class="token punctuation">)</span><span class="token punctuation">)</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 这个hoistStatic会将WrappedComponent中非React的staticFileds绑定到Connect组件上</span>
    <span class="token keyword">return</span> <span class="token function">hoistStatics</span><span class="token punctuation">(</span>Connect<span class="token punctuation">,</span> WrappedComponent<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><h2 id="后记"><a href="#后记" aria-hidden="true" class="header-anchor">#</a> 后记</h2><p>只看懂了90%。还有三个地方不理解</p><ol><li>为何能从props中能获取到store</li><li>addExtraProps里的骚操作</li><li>Connect为何要重新声明childContextTypes和getChildContext</li></ol><h2 id="参考资料"><a href="#参考资料" aria-hidden="true" class="header-anchor">#</a> 参考资料</h2><p><a href="https://github.com/reduxjs/react-redux" target="_blank" rel="noopener noreferrer">React-redux github repo</a></p><p><a href="https://github.com/reduxjs/react-redux/blob/master/docs/api.md#api" target="_blank" rel="noopener noreferrer">React-redux API reference</a></p><p><a href="https://redux.js.org/api/" target="_blank" rel="noopener noreferrer">Redux API refenrence</a></p></div><!----><!----></div></div></div>
    <script src="/assets/js/7.5fb1dc3c.js" defer></script><script src="/assets/js/app.0caf2975.js" defer></script>
  </body>
</html>
