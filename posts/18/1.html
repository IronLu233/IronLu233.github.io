<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Iron&#39;s Blog | JSDoc 快乐入门</title>
    <meta name="description" content="Just recording something">
    
    
    <link rel="preload" href="/assets/css/23.styles.40677ac6.css" as="style"><link rel="preload" href="/assets/js/app.0caf2975.js" as="script"><link rel="preload" href="/assets/js/13.1594182b.js" as="script"><link rel="prefetch" href="/assets/js/0.9f59e96c.js"><link rel="prefetch" href="/assets/js/1.9710c8e3.js"><link rel="prefetch" href="/assets/js/2.717bf58a.js"><link rel="prefetch" href="/assets/js/3.eb3ce0d5.js"><link rel="prefetch" href="/assets/js/4.81a9fd94.js"><link rel="prefetch" href="/assets/js/5.0289cb67.js"><link rel="prefetch" href="/assets/js/6.58a56d39.js"><link rel="prefetch" href="/assets/js/7.5fb1dc3c.js"><link rel="prefetch" href="/assets/js/8.af6cf755.js"><link rel="prefetch" href="/assets/js/9.d4b854ad.js"><link rel="prefetch" href="/assets/js/10.f94d82bf.js"><link rel="prefetch" href="/assets/js/11.68ad2dfd.js"><link rel="prefetch" href="/assets/js/12.fe4f1f96.js"><link rel="prefetch" href="/assets/js/14.5e2158c7.js"><link rel="prefetch" href="/assets/js/15.cb7e4c09.js"><link rel="prefetch" href="/assets/js/16.637e1af2.js"><link rel="prefetch" href="/assets/js/17.c68f0f15.js"><link rel="prefetch" href="/assets/js/18.3f6c685d.js"><link rel="prefetch" href="/assets/js/19.5d57c2ad.js"><link rel="prefetch" href="/assets/js/20.725e2252.js"><link rel="prefetch" href="/assets/js/21.c0d37235.js"><link rel="prefetch" href="/assets/js/22.c549c2ec.js">
    <link rel="stylesheet" href="/assets/css/23.styles.40677ac6.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div><a href="/" class="home-link router-link-active"><!----><span class="site-name">
      Iron's Blog
    </span></a><div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""><!----></div><!----></div></header><div class="sidebar-mask"></div><div class="sidebar"><!----><!----></div><div class="page"><div class="content"><h1 id="jsdoc-快乐入门"><a href="#jsdoc-快乐入门" aria-hidden="true" class="header-anchor">#</a> JSDoc 快乐入门</h1><blockquote><p>程序员最讨厌的四件事，写注释、写文档、别人不写注释、别人不写文档。</p></blockquote><h2 id="jsdoc-是什么，为什么我们需要它"><a href="#jsdoc-是什么，为什么我们需要它" aria-hidden="true" class="header-anchor">#</a> JSDoc 是什么，为什么我们需要它</h2><h3 id="为什么我们要写注释"><a href="#为什么我们要写注释" aria-hidden="true" class="header-anchor">#</a> 为什么我们要写注释</h3><p>JSDoc 首先是文档注释，文档注释是注释。我们写注释的目的，基本上是以下两点</p><p>让别人理解你的代码，和让自己理解自己的代码。</p><p>第一点容易理解，每个人写代码风格千差万别，我们不能保证他人能接受我们的自己的编程风格（比如我就会用大量的<code>map</code>, <code>reduce</code>, <code>filter</code>等高阶函数辅以老牌函数式编程工具库<code>lodash</code>）。注释至少能让他人明白我们代码的意图，知晓意图后，理解代码具体逻辑就会容易一些。另外，各种业务代码中的 Hack，如果不写注释，常常会让后面的维护者疑惑。</p><p>第二点，让自己理解自己的代码。在书写新代码时，如果业务复杂，不可避免会导致代码长度增加。注释能让我们帮助我们在脑内对我们写的东西，有个大概的框架，减少写出缺乏大局观的代码的可能。另一种情况，我们自己要在过去自己所负责的那片代码上进行业务迭代。这些注释能帮助我们回忆起之前业务代码上的一些细节。</p><p>从上面两方面看来，写注释最大的好处是，减少他人与自己理解代码的成本，并且更容易进入工作状态，更好更快地完成项目迭代，更快地下班，也有更多的时间跑崽。</p><p><s>写注释是以极少量的成本，却表达了对同事和自己的爱意</s></p><h3 id="为什么选择-jsdoc"><a href="#为什么选择-jsdoc" aria-hidden="true" class="header-anchor">#</a> 为什么选择 JSDoc</h3><p>JSDoc 是一种统一的注释规范，它以<code>/**</code>或者<code>/***</code>开头，以<code>*/</code>结尾。比起 js 中基本的两种注释<code>//</code>和<code>/* */</code>，它具有以下优点</p><ol><li>统一且和谐的注释风格，降低团队内理解文档的成本。</li><li>具有一套比较完善的类型系统，提高代码可维护性。</li><li>主流的编辑器和 IDE 会对类型注释等提供较好的支持，比如开发工具会提供 JSDoc 的代码片段，通过类型注释提供相应的自动补全提示等等。</li><li>无需任何配置，只要学会就能立即在项目中使用并获得收益。</li></ol><p>当然，它也有这样的缺点。</p><ol><li>类型系统对泛型的支持较羸弱，某些场景下只能退而求其次。</li><li>JSDoc 具有一定的学习成本，对于未接触过静态类型语言的初学者可能会不好理解。</li></ol><p>不过，瑕不掩瑜。对于上面的四点收益，下面的两点缺点也是可以克服和接受的。</p><h2 id="类型系统"><a href="#类型系统" aria-hidden="true" class="header-anchor">#</a> 类型系统</h2><p>类型，会紧随在 JSDoc 的标签后，,被含在<code>{</code>和<code>}</code>中。下面是一些例子。</p><p>下面的类型系统部分与 TypeScript 中的类型系统有大量相通之处，并且在主流编辑器中，混用他们大部分时候是没有问题的。</p><pre class="language-js"><code><span class="token comment">/**
 * 标注类型
 * @type {number}
 */</span>
<span class="token comment">/**
 * 自定义一个类型
 * @typedef SomeType
 * @property {string}
 */</span>
<span class="token comment">/**
 * 标注返回值
 * @returns {Function}
 */</span>
<span class="token comment">/**
 * 标注参数
 * @param {boolean} isVisible
 */</span>
</code></pre><h3 id="基本类型"><a href="#基本类型" aria-hidden="true" class="header-anchor">#</a> 基本类型</h3><p>此处全当复习 JS 的类型系统，大家都明白的</p><table><thead><tr><th>类型</th><th>含义</th></tr></thead><tbody><tr><td>number</td><td>数字</td></tr><tr><td>boolean</td><td>布尔值, <code>true</code> or <code>false</code></td></tr><tr><td>string</td><td>字符串</td></tr><tr><td>null</td><td>Null 类型</td></tr><tr><td>undefined</td><td>undefined 类型</td></tr><tr><td>object</td><td>代表一切非基本类型</td></tr><tr><td>any（或者*）</td><td>任意类型</td></tr></tbody></table><h3 id="类型组合"><a href="#类型组合" aria-hidden="true" class="header-anchor">#</a> 类型组合</h3><h4 id="数组"><a href="#数组" aria-hidden="true" class="header-anchor">#</a> 数组</h4><p>数组的表示方法极其简单，既可以在类型后面加方括号，形如<code>T[]</code>，也可以<code>Array&lt;T&gt;</code>这样写（这里的<code>T</code>泛指一切类型）</p><pre class="language-js"><code><span class="token comment">/**
 * @type {number}
 */</span>
<span class="token keyword">const</span> scores <span class="token operator">=</span> <span class="token function">fetchScore</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><h4 id="字符、数字字面量类型"><a href="#字符、数字字面量类型" aria-hidden="true" class="header-anchor">#</a> 字符、数字字面量类型</h4><p>用<code>|</code>将每个字面量隔开
<img src="/assets/img/1.9dd31fa7.png" alt></p><h4 id="联合类型"><a href="#联合类型" aria-hidden="true" class="header-anchor">#</a> 联合类型</h4><p>我们传入的参数可能是多种类型中的某个，便是联合类型的使用场合。它的语法与上面的字面量类型相同。也用<code>|</code>隔开。</p><pre class="language-js"><code><span class="token comment">/**
 * 一个例子
 * @param {number|string} value 具有多种类型的值
 * @param {number} padding 内边距
 */</span>
<span class="token keyword">function</span> <span class="token function">padLeft</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> padding<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> padding <span class="token operator">===</span> <span class="token string">'number'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">Array</span><span class="token punctuation">(</span>padding <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span> <span class="token operator">+</span> value<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> padding <span class="token operator">===</span> <span class="token string">'string'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> padding <span class="token operator">+</span> value<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`Expected string or number, got '</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>padding<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">'.`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><h4 id="交错类型"><a href="#交错类型" aria-hidden="true" class="header-anchor">#</a> 交错类型</h4><p>交叉类型可以叠加多个类型形成新的类型，这个在 React 组件中给组件的 props 注解类型极为有用。
下面的例子中，Vscode 会自动补全 Ant design 的 Form 属性中的各种相关方法</p><pre class="language-js"><code><span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> React <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> Form<span class="token punctuation">,</span> Input <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'antd'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> FormComponentProps <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'antd/lib/form'</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token punctuation">{</span> Item<span class="token punctuation">:</span> FormItem <span class="token punctuation">}</span> <span class="token operator">=</span> Form<span class="token punctuation">;</span>

<span class="token comment">/**
 * @type {React.FC&lt;FormComponentProps &amp; { otherProps: Function }&gt;}
*/</span>
<span class="token keyword">const</span> UserForm<span class="token punctuation">:</span>  <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> form <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>

  <span class="token keyword">const</span> <span class="token punctuation">{</span> getFieldDecorator <span class="token punctuation">}</span> <span class="token operator">=</span> form<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>Form<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>FormItem<span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token function">getFieldDecorator</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>Input <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>FormItem<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>Form<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p><img src="2.png" alt></p><h4 id="索引类型"><a href="#索引类型" aria-hidden="true" class="header-anchor">#</a> 索引类型</h4><p>很多时候我们使用 object 注解类型还不够详细，这个时候，索引类型就出马了。
它的类型是这样写的。<code>TV</code>为对象值的类型，可替换为任何类型，<code>TK</code>为键类型，必须为<code>number</code>或者<code>string</code>或者它们的子集（比如用上面提到的字面量类型或者<code>keyof</code>关键字）</p><pre class="language-js"><code><span class="token comment">/**
 * @type {{[key: TK]: TV}}
 */</span>
</code></pre><p><img src="3.png" alt></p><h4 id="自定义一个类型"><a href="#自定义一个类型" aria-hidden="true" class="header-anchor">#</a> 自定义一个类型</h4><p>自定义类型使用<code>@typedef</code>标签定义。
下面的这个例子包含了常用的情况</p><pre class="language-js"><code><span class="token comment">// 第一种情况，我真的想定义一个新的类型</span>
<span class="token comment">/**
 * @typedef TableRow
 * @property {number} age 年龄
 * @property {string} name 姓名
 * @property {boolean} isChecked 是否选中
 * @property {string?} ID 身份ID，为空时未登记
 */</span>

<span class="token comment">// 第二种情况，我想为某个类型定义一个别名</span>
<span class="token comment">/**
 * @typedef {1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24} Hour
 */</span>
</code></pre><h2 id="如何在各个场景下使用-jsdoc"><a href="#如何在各个场景下使用-jsdoc" aria-hidden="true" class="header-anchor">#</a> 如何在各个场景下使用 JSDoc</h2><p>下面我会用各种例子来说明，如何在代码中实践 Jsdoc 并获得收益</p><h3 id="注解方法（公共方法，类方法等）"><a href="#注解方法（公共方法，类方法等）" aria-hidden="true" class="header-anchor">#</a> 注解方法（公共方法，类方法等）</h3><pre class="language-js"><code><span class="token comment">/**
 * @author Iron&lt;lujianwei@duiba.com.cn&gt;
 */</span>
<span class="token keyword">import</span> sortBy <span class="token keyword">from</span> <span class="token string">'lodash/sortBy'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> last <span class="token keyword">from</span> <span class="token string">'lodash/last'</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * 对数组分组。数组中位置相邻且为连续的数字会被分到一个数组
 * @param {number[]} list 待分组数组
 * @returns {number[][]}
 * @example
 * ``` js
 * groupByConsequent([1, 2, 3, 4, 6, 8, 9, 10, 11, 12, 13, 15]);
 * // 返回值为[[1, 2, 3, 4], [6], [8, 9, 10, 11, 12, 13], [15]]
 * ```
 */</span>
<span class="token keyword">function</span> <span class="token function">groupByConsequent</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">sortBy</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>prev<span class="token punctuation">,</span> current<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> prevGroup <span class="token operator">=</span> <span class="token function">last</span><span class="token punctuation">(</span>prev<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> prevHour <span class="token operator">=</span> <span class="token function">last</span><span class="token punctuation">(</span>prevGroup<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>prevGroup <span class="token operator">||</span> <span class="token punctuation">(</span>prevHour <span class="token operator">!==</span> current <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> prevHour <span class="token operator">!==</span> current<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">...</span>prev<span class="token punctuation">,</span> <span class="token punctuation">[</span>current<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">...</span>prev<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">...</span>prevGroup<span class="token punctuation">,</span> current<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> groupByConsequent<span class="token punctuation">;</span>
</code></pre><h3 id="注解-react-组件"><a href="#注解-react-组件" aria-hidden="true" class="header-anchor">#</a> 注解 React 组件</h3><h4 id="函数式组件"><a href="#函数式组件" aria-hidden="true" class="header-anchor">#</a> 函数式组件</h4><p>在 React 中，无状态的函数式组件的泛型类为<code>React.FunctionComponent</code>，或者为<code>React.FC</code>，或者为<code>React.SFC</code>，如果你的 React 版本 &lt;= 16.8，建议使用<code>SFC</code>，否则可用<code>FC</code>。而<code>FunctionComponent</code>为<code>FC</code>的全称，任何版本都可用。<code>SFC</code>为 Stateless Function Component。由于 React16.8 更新了 React Hooks，使得函数式组件可以带上状态，因此称为 SFC 是不合适的。</p><p>第一个例子，一个业务代码中的 Modal，接收<code>visible</code>和<code>onCloseIndexDetailModal</code>两个参数。他们的类型分别为 boolean 和 Function</p><pre class="language-jsx"><code><span class="token comment">/**
 * @typedef ComparableChartIndexModalProps
 * @property {boolean} visible 弹窗可见性
 * @property {Function} onCloseIndexDetailModal 关闭弹窗时的回调
 */</span>

<span class="token comment">/**
 * 可比较属性点击后的带折线图的弹层
 * @type {React.FunctionComponent&lt;ComparableChartIndexModalProps&gt;}
 */</span>
<span class="token keyword">const</span> <span class="token function-variable function">ComparableChartIndexModal</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> visible<span class="token punctuation">,</span> onCloseIndexDetailModal <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Modal</span>
      <span class="token attr-name">visible</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>visible<span class="token punctuation">}</span></span>
      <span class="token attr-name">width</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token number">724</span><span class="token punctuation">}</span></span>
      <span class="token attr-name">footer</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token keyword">null</span><span class="token punctuation">}</span></span>
      <span class="token attr-name">onCancel</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>onCloseIndexDetailModal<span class="token punctuation">}</span></span>
    <span class="token punctuation">&gt;</span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ChartOptionForm</span> <span class="token punctuation">/&gt;</span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ComparableIndexChart</span> <span class="token punctuation">/&gt;</span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Modal</span><span class="token punctuation">&gt;</span></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><h4 id="类组件"><a href="#类组件" aria-hidden="true" class="header-anchor">#</a> 类组件</h4><p>就把上面的 Modal 改为类组件。我们需要用<code>@extend</code>注解，告诉编辑器和自己，下面的组件继承自<code>React.Component&lt;ComparableChartIndexModalProps, ComparableChartIndexModalProps&gt;</code>。其中<code>ComparableChartIndexModalProps</code>也是我们上面的属性。<code>ComparableChartIndexModalState</code>为组件 state 的类型。之后，我们就能从<code>this.state</code>和<code>this.props</code>中得到其中的各个带类型的属性。</p><pre class="language-jsx"><code><span class="token comment">/**
 * @typedef ComparableChartIndexModalProps
 * @property {boolean} visible 弹窗可见性
 * @property {Function} onCloseIndexDetailModal 关闭弹窗时的回调
 */</span>

<span class="token comment">/**
 * @typedef ComparableChartIndexModalState
 * @property {number} openCount Modal打开的次数
 */</span>

<span class="token comment">/**
 * 可比较属性点击后的带折线图的弹层
 * @extends {React.Component&lt;ComparableChartIndexModalProps, ComparableChartIndexModalState&gt;}
 */</span>
<span class="token keyword">class</span> <span class="token class-name">ComparableChartIndexModal</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span> visible<span class="token punctuation">,</span> onCloseIndexDetailModal <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Modal</span>
        <span class="token attr-name">visible</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>visible<span class="token punctuation">}</span></span>
        <span class="token attr-name">width</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token number">724</span><span class="token punctuation">}</span></span>
        <span class="token attr-name">footer</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token keyword">null</span><span class="token punctuation">}</span></span>
        <span class="token attr-name">onCancel</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>onCloseIndexDetailModal<span class="token punctuation">}</span></span>
      <span class="token punctuation">&gt;</span></span><span class="token plain-text">
        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ChartOptionForm</span> <span class="token punctuation">/&gt;</span></span><span class="token plain-text">
        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ComparableIndexChart</span> <span class="token punctuation">/&gt;</span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Modal</span><span class="token punctuation">&gt;</span></span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><h3 id="注解变量类型"><a href="#注解变量类型" aria-hidden="true" class="header-anchor">#</a> 注解变量类型</h3><p>使用<code>@type</code>标签注解类型</p><pre class="language-js"><code><span class="token comment">/**
 * @typedef TableRow
 * @property {number} age 年龄
 * @property {string} name 姓名
 * @property {boolean} isChecked 是否选中
 * @property {string?} ID 身份ID，为空时未登记
 */</span>

<span class="token comment">/**
 * @type {TableRow}
 */</span>
<span class="token keyword">const</span> row <span class="token operator">=</span> <span class="token function">getCertainRow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><h3 id="从外部（-d-ts-文件等）引入类型"><a href="#从外部（-d-ts-文件等）引入类型" aria-hidden="true" class="header-anchor">#</a> 从外部（.d.ts 文件等）引入类型</h3><pre class="language-js"><code><span class="token comment">// 可以使用直接通过import语句导入的类型</span>
<span class="token comment">// 如果触发了eslint的unused var规则，可以用第二种方法</span>
<span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * @type {React.FC&lt;{}&gt;}
 *
 */</span>

<span class="token comment">// 第二种，使用typedef + import引入</span>
<span class="token comment">/**
 * @typedef {import('antd/lib/form').FormComponentProps} FormComponentProps
 */</span>
</code></pre><h2 id="何时使用-jsdoc-注解组件、方法、类型。"><a href="#何时使用-jsdoc-注解组件、方法、类型。" aria-hidden="true" class="header-anchor">#</a> 何时使用 JSDoc 注解组件、方法、类型。</h2><p>对于公共组件和公共方法，通过 JSdoc 注解类型并且写上提示性的问题收益是极大的。这样会使得调用你写的公共组件、方法的同事使用它们的难度，增进同事之间的友情
<s>（和基情）</s></p><p>对于业务组件，强烈建议书写。业务组件的 props 可能会很长，对 props 类型和含义的注释，能显著减少他人的维护成本。</p><p>至于类方法中的各种回调，个人认为有时间可以写一下，让别人更容易明白你的代码。</p><p>最后关于变量的类型注释，请酌情考虑自动补全带来的收益与写类型注解的成本。比如 React 中有个<code>React.CSSProperties</code>属性，可以告诉编辑器，这个变量是会成为 React 组件的 Style 的，可以考虑使用。</p><h2 id="最后一些想法"><a href="#最后一些想法" aria-hidden="true" class="header-anchor">#</a> 最后一些想法</h2><p>这篇文章讲 JSDoc 与 React，仅仅只是入门用，许多想讲的地方因为篇幅原因未能完善。大家可以移步<a href="http://usejsdoc.org/index.html" target="_blank" rel="noopener noreferrer">JSDoc 官网</a>和<a href="http://www.typescriptlang.org/docs/handbook/basic-types.html" target="_blank" rel="noopener noreferrer">TypeScript 官网</a>。特别是类型系统和泛型的使用。
最后，个人对 JSDoc 的看法是</p><blockquote><p>JSDoc is the gateway to TypeScript!😂</p></blockquote></div><!----><!----></div></div></div>
    <script src="/assets/js/13.1594182b.js" defer></script><script src="/assets/js/app.0caf2975.js" defer></script>
  </body>
</html>
