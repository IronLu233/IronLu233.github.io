(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{58:function(t,e,r){t.exports=r.p+"assets/img/5.cba845f3.png"},59:function(t,e,r){t.exports=r.p+"assets/img/4.1c66b3b2.png"},60:function(t,e,r){t.exports=r.p+"assets/img/3.5c50caf2.png"},61:function(t,e,r){t.exports=r.p+"assets/img/1.899ec5da.png"},86:function(t,e,r){"use strict";r.r(e);var o=[function(){var t=this,e=t.$createElement,o=t._self._c||e;return o("div",{staticClass:"content"},[o("h1",{attrs:{id:"react-高阶函数与-typescript"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#react-高阶函数与-typescript","aria-hidden":"true"}},[t._v("#")]),t._v(" React 高阶函数与 TypeScript")]),o("h2",{attrs:{id:"background"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#background","aria-hidden":"true"}},[t._v("#")]),t._v(" Background")]),o("p",[t._v("在 React-Native 的开发中，遇到一个这样的问题：")]),o("p",[t._v("在一开始的技术选型上，使用了"),o("code",[t._v("react-router")]),t._v("，在页面写好了之后，发现 React-Router 在 React-Native 下有 2 个缺陷")]),o("ol",[o("li",[t._v("页面始终在一个 Activity 上，当用户点击返回时，会直接退回到桌面")]),o("li",[t._v("React-Router 的 history.goBack()方法在 iOS 上无效")])]),o("p",[t._v("第一个问题可以通过对"),o("code",[t._v("BackHandler")]),t._v("添加 listener 来解决，但第二个问题我并没有找到解决方法。")]),o("p",[t._v("最终将决定将"),o("code",[t._v("react-router")]),t._v("换为"),o("code",[t._v("react-navigation")]),t._v("来实现路由和导航。")]),o("p",[o("code",[t._v("react-navigation")]),t._v("的路由声明方式和"),o("code",[t._v("react-router")]),t._v("有很大不同，他的路由声明是这样的。\n"),o("img",{attrs:{src:r(61),alt:""}}),t._v("\n而且"),o("code",[t._v("createStackNavigator")]),t._v("返回的"),o("code",[t._v("RootStack")]),t._v("组件外不能包裹父组件，否则无法运行，这导致"),o("code",[t._v("redux")]),t._v("的 "),o("code",[t._v("Provider")]),t._v(" 组件不能包裹在"),o("code",[t._v("RootStack")]),t._v("外。")]),o("h2",{attrs:{id:"solution"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#solution","aria-hidden":"true"}},[t._v("#")]),t._v(" Solution")]),o("h3",{attrs:{id:"高阶函数-hoc"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#高阶函数-hoc","aria-hidden":"true"}},[t._v("#")]),t._v(" 高阶函数(HOC)")]),o("p",[t._v("通过 React 的高阶函数，使得传入高阶函数的"),o("code",[t._v("Component")]),t._v("外层被包裹上"),o("code",[t._v("<Provider store={store}><Component /><Provider>")]),t._v("，这样"),o("code",[t._v("Component")]),t._v("中的"),o("code",[t._v("connect")]),t._v("方法就能从"),o("code",[t._v("redux")]),t._v("注入到"),o("code",[t._v("component")]),t._v("的"),o("code",[t._v("props")]),t._v("中了。")]),o("p",[t._v("我们先写一个不带类型的"),o("code",[t._v("withProvider")]),t._v(" ("),o("strong",[t._v("代码里会留有一些问题，下面会讲到")]),t._v(")")]),o("p",[t._v("然后我们用 TypeScript 加上类型\n"),o("img",{attrs:{src:r(60),alt:""}}),t._v("\n接着我们会发现，TypeScript 报了这样一个语法错误:")]),o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[t._v("[ts] JSX element type 'Component' does not have any construct or call signatures.\n")])]),o("p",[t._v("通过 Google，在 Stackoverflow 上的\n"),o("a",{attrs:{href:"https://stackoverflow.com/questions/31815633/what-does-the-error-jsx-element-type-does-not-have-any-construct-or-call",target:"_blank",rel:"noopener noreferrer"}},[t._v("这里")]),t._v("\n找到了这个问题的答案\n在高阶函数的第一层，我们传入的 Component 其实是一个组件的构造函数，而不是 Component 的一个实例。")]),o("p",[t._v("因此，将 Component 的类型定义为 React.Component 显然是把他当做实例了。我们应该将 Component 的类型定义为: (Component: new (props: P) => React.Component)")]),o("p",[t._v("当然"),o("code",[t._v("typeof React.Component")]),t._v("更简单。一个类的 type 就是他的构造函数")]),o("p",[t._v("那么我们的代码就可以改成这样\n"),o("img",{attrs:{src:r(59),alt:""}})]),o("h3",{attrs:{id:"解决-component-静态方法丢失问题"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#解决-component-静态方法丢失问题","aria-hidden":"true"}},[t._v("#")]),t._v(" 解决 Component 静态方法丢失问题")]),o("p",[t._v("仔细看上面我们写的代码，定义在 Component 上的静态方法并没有被我们加入到外层的 WithProvider 中，在我的这个项目中，"),o("code",[t._v("react-navigation")]),t._v("通过读取组件的 static property 中的"),o("code",[t._v("navigationOptions")]),t._v("来获取各个 screen 导航栏的配置，当他被 withProvider 包裹之后，"),o("code",[t._v("navigationOptions")]),t._v("上的信息就丢失了。我们需要在高阶函数中将"),o("code",[t._v("Component")]),t._v("的静态方法和属性复制到"),o("code",[t._v("WithProvider")]),t._v("组件中。")]),o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[t._v("// ... the code before.\nWithProvider.navigationOptions = Component.navigationOptions;\nreturn WithProvider;\n")])]),o("p",[t._v("当然如果静态的方法和属性比较多，手写复制是比较麻烦的，社区为我们提供了一个偷懒的方式\n使用"),o("a",{attrs:{href:"https://github.com/mridgway/hoist-non-react-statics",target:"_blank",rel:"noopener noreferrer"}},[t._v("hoist-non-react-statics")]),t._v("可以非常愉快地复制这些静态的属性和方法。\n"),o("img",{attrs:{src:r(58),alt:""}})]),o("h3",{attrs:{id:"ref-丢失问题"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#ref-丢失问题","aria-hidden":"true"}},[t._v("#")]),t._v(" Ref 丢失问题")]),o("p",[t._v("待更新")]),o("h2",{attrs:{id:"参考"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#参考","aria-hidden":"true"}},[t._v("#")]),t._v(" 参考")]),o("p",[o("a",{attrs:{href:"https://www.typescriptlang.org/docs/handbook/classes.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("TypeScript 官方文档关于 class 类型和构造函数的部分")])]),o("p",[o("a",{attrs:{href:"https://stackoverflow.com/questions/31815633/what-does-the-error-jsx-element-type-does-not-have-any-construct-or-call",target:"_blank",rel:"noopener noreferrer"}},[t._v("StackoverFlow")]),t._v(":")]),o("p",[o("a",{attrs:{href:"https://github.com/mridgway/hoist-non-react-statics",target:"_blank",rel:"noopener noreferrer"}},[t._v("Hoist-non-react-statics")])])])}],a=r(0),n=Object(a.a)({},function(){this.$createElement;this._self._c;return this._m(0)},o,!1,null,null,null);e.default=n.exports}}]);